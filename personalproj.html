<!DOCTYPE html>
<!--Personal projects page-->
<html lang="en">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=0.3, minimum-scale=0.1">
    <head>
        <meta charset="utf-8">
        <title>Riddhi Patel's Portfolio Page</title>
        <link rel="stylesheet" href="projcustom.css">
        
    </head>

    <body>
        <div class="personalprojectspage">
        
            <i><h1 style="font-size:60px">Personal Projects</h1></i>

            <p1 style="font-size:20px">
                Right now, I’m pouring my time and passion into projects that revolve around Data Analysis and Data Science fundamentals. I pick projects based on the intriguing questions I want to answer or everyday problems I want to solve. As I dive into these projects, I’m not just expanding my knowledge, but also turning my findings into something tangible - like a deployable app or a web interface. Below, you’ll find a list of my projects along with their respective repositories. If they’re ready for the world to see, I’ve included a website link!
            </p1>
            <br></br>
            <br></br>
            <br></br>
            <br></br>
            <br></br>

           <left> <i><h1 style="font-size:20px">MyAniMate: A hybrid weighted recommendation system</h1></i></left>
            <p1 style="font-size:15px">
                After getting the hang of content and collaborative filtering, I thought it’d be cool to build my own recommendation system. Crunchyroll’s slow UI and Netflix’s limited anime options were kind of a bummer. So, I made MyAniMate to find new animes for myself. However, the system has a limitation where the dataset only expands up to 2023 user ratings and animes. 
            </p1>
            <br></br>
            <ul style="line-height:160%">
                <li><b>Notebook:</b><a href="https://github.com/rp1177/AnimeRecommendation/blob/main/AnimeRecSystem.ipynb">Click here</a></li> 
                <li><b>Language used:</b> Python/Jupyter Notebook</li> 
                <li><b>Libraries used:</b> Fuzzywuzzy, Ipyplot, Pandas, Matplotlib, Nltk, Numpy, and Scikit-learn</li>
                <li><b>Development Process:</b>
                    <ul style="line-height:170%">
                        <li>1.) Downloaded a dataset from Kaggle and loaded it into a DataFrame.</li>
                        <li>2.) Initiated data cleaning and preprocessing, focusing on handling null values and ensuring data quality.</li>
                        <li>3.) Used a heatmap to visualize missing values, decided to ignore them to avoid introducing biases.</li>
                        <li>4.) Performed feature engineering by merging genres, synopsis, and TV-ratings into a ‘tags’ column using NLP techniques.</li>
                        <li>5.) For content based filtering, calculated similarity scores using TF-IDF and cosine similarity.</li>
                        <li>6.) For collaborative based filtering, developed a popularity metric column using weighted overall scores and number of favorites.</li>
                        <li>7.) Combined the average 'tags' content score with popularity score, multiplied by the weights.</li>
                        <li>8.) Implemented a user-input interface allowing user to give an input list of favorite animes which finds the average score and frequent genre.</li>
                        <li>9.) Subtract user's average score against the rest of the scores. The top 30 smallest difference in scores will be recommended to user.</li>
                    </ul>

                    <li><b>Future Developments:</b> Currently testing different weights and use cases of the recommendation system. In addition to that, a website is still under construction.
                </li>
            </ul>

            <br></br>
            <br></br>
            <br></br>
            <br></br>

            <left> <i><h1 style="font-size:20px">Notifications Discord Bot</h1></i></left>
            <p1 style="font-size:15px">
                I created the Notifications discord bot as a means to learn RESTful API communication and integration practices. However, I also wanted to try and solve an everyday issue I have, which is email organization. I thought this could be a way I can efficiently organize and read my emails faster while using an application I am always actively checking. By allowing my bot to communicate with the Gmail API, I use base64 decoding and BeautifulSoup webscraping libraries to extract my most unread emails every couple of minutes and send them as embeds in Discord within a specified channel. From there I can be able to actively communicate with my inbox with ease. More developments are yet to come.
            </p1>
            <br></br>
            <ul style="line-height:160%">
                <li><b>Code:</b><a href="https://github.com/rp1177/Miscellaneous/tree/main/Notifications_Bot">Click here</a></li> 
                <li><b>Language used:</b> Python (3.8)</li> 
                <li><b>Libraries used:</b>BeautifulSoup, base64, discord.py, googleapiclient, re</li>
                <li><b>Development Process:</b>
                    <ul style="line-height:170%">
                        <li>1.) Create the Bot: Use the Discord Developer portal to create a bot and set the necessary permissions. </li>
                        <li>2.) Connect to Discord API: Use discord.py to authenticate and connect the bot to the Discord API.</li>
                        <li>3.) Set Up Google API: Authenticate with Google and enable the Gmail API. Set up the necessary scopes and permissions.</li>
                        <li>4.) Fetch Emails: Use the Gmail API to get the most recent unread emails from your inbox.</li>
                        <li>5.) Process Emails: Use BeautifulSoup and base64 to extract and decode the email details (thread_id, message_content, date/time). Store this information in a list.</li>
                        <li>6.) Create Discord Embeds: Set up a task loop that runs every few minutes to check the list of emails, scrape the email data using BeautifulSoup with base64 decoding, and create a new Discord embed for each email. The bot will post these embeds in a specified channel with options to mark the email as read or delete it.</li>
                        <li>7.) Host the Bot: Upload the bot code to a hosting service.</li>
                        
                    </ul>

                    <li><b>Future Developments:</b> Add more commands to efficiently communicate with my inbox using Gmail API. Additionally, allow the bot to notify me of data breaches that may impact me.
                </li>
            </ul>
            
            
        </div>
    </body>